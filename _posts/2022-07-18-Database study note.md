---
title: Database study note
tags: note
article_header:
  type: cover
  #image:
    #src: /screenshot.jpg
    #bundle exec jekyll serve
key: studynote
---

I'm using this blog as a personal notebook, so contents are not arranged in a way that best explain the topic.

### Textbook database data storage structure:

1. Files (stores records sequentially)
   - support scans well
2. B+ Tree
    - support point lookup well
    - Stores pointers on leaf node which points to the actual data. The data must be stored somewhere else (files).
        - Why not store values, instead of pointers, in the leaf node so we can get rid of Files?
            - Then we can’t support scans fast enough since each leaf node requires a disk seek.

It’s possible to just have one data storage structure (e.g., either one of Files, B-Tree, a modified version of B+ Tree proposed above can do the work) to store all data and support all operations, however they sacrifice performance. LSM tree is yet another data storage structure that can work alone and well. Let’s examine what it sacrifices and why rocksdb chooses to use it.

LSM tree: optimized for write, since they don’t incur disk IO. Lookup is bad because lookup operates on each of the trees L0, ... , Lk, and merges the results of each tree. (We can use bloom filter to optimize it) Scans are okay. (leaves are sequential allocated, each tree incurs one disk seek. Worse than Files, but better than B+ Tree.)

---

### Makefile and CMake

##### Makefile:

The Makefile uses .o files, and those object files allow us to avoid compile everything when just one file changed. Object files (or object code) are machine code files generated by a compiler from source code. The difference with an executable is that the object file isn't linked, so references to functions, symbols, etc aren't defined yet (their memory addresses is basically left blank).

The compilation of a C++ program involves three steps:
1. Preprocessing: we don’t need to worry about this step
2. Compilation: the compiler takes the pre-processor's output and produces an object file from it. Examples below:
    - g++ -c main.cpp //-c declares compliation only. (no linking)
    - g++ -c foo.c -o foo.o              // Object file for foo.c  
	  g++ -c bar.c -o bar.o              // Object file for bar.c  
	  g++ -c main.c -o main.o        // Object file for main.c
3. Linking: the linker takes the object files produced by the compiler and produces either a library or an executable file.
    - g++ main.o -omain //link main.o with standard library and output executable
    - g++ foo.o bar.o main.o -o software // Executable (foo + bar + main)

Note:
- It’s fine to mix object files and source files when compiling. (The compiler will handle compiling and linking behind the scenes.)
    - g++ file1.o file2.cc -o prog
- Undefined variables in Makefile are treated as empty strings

##### CMake:

cmake -S ../ -B . (assume in the build/)
cmake -DWITH_SNAPPY=1 .. (set options from command line)

commands:
- project() ${PROJECT_NAME}
- add_executable() # name src
- add_subdirectory()
- add_library()
- target_include_directories() # just set the include path, doesn’t actually include files into your source code. so that you can use include<> instead of include “”
- target_link_libraries()
- git submodule add reop dir

This is a git thing. If a git repository also uses CMake, you can easily integrate that library into your CMake project.

<!--more-->
